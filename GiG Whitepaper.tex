\documentclass{article}
\usepackage{amsmath}
\usepackage{hyperref}
\title{GiG: A Decentralized Platform for the Gig Economy}
\author{Ishtar Eve}
\date{February 2019}
\begin{document}
   \maketitle
   \begin{abstract}
A decentralized application for the labor marketplace that connects employers with independent contractors is described. GiG is intended to reduce friction and to eliminate fees collected by employment agencies, recruiting platforms, and financial institutions. Common bugs will be avoided by using Plutus, the strongly typed functional programming language of the Cardano blockchain. 

\paragraph{} The native currency of the system is the Gig Economy Token (GET). The algorithm used for its creation prevents speculative bubbles, and funds a Treasury System DAO (Decentralized Autonomous Organization). The DAO finances expenses for the ecosystem through proposals created and voted by the GiG community.

\paragraph{} GiG offers multiple tools that will give value to freelancers and employers, gaining the ability to interact without the need of trust, transacting on a peer to peer basis (without using financial institutions).

\paragraph{}(Specific information about GiG functionalities on this section using bulletpoints).

\paragraph{} Note: GiG is under construction. New versions of this paper will be updated periodically.

\end{abstract}

\section{Introduction}

(Current state of the gig economy marketplace, problems that the GiG protocol solves.)

A study by Intuit predicts that the gig economy will be about 43\% of the workforce by 2020.

(Paper organization)

(Thoughts)
\paragraph{} All around the world, there's lots of work that needs to be done, and many people that need to work. Unfortunately, the people who are willing to pay a certain amount of money for a certain work to be done, very often can't connect with the people who would benefit from the working opportunity and who would be willing to do the work in exchange for such amount.

\section{GET Token Creation}
GET tokens are created when ADA is received by the GET creation smart contract (GCSM).
The amount of GET created and awarded to the ADA sender's wallet $\alpha$, will be an arbitrary constant $\phi$ (currently set to 1000 GET), divided by the block height $\ell$, starting from the first block since the GET creation smart contract gets published. That is,
\[ \alpha
  = \dfrac{\phi}{\ell}
\]

\section{Treasury System and DAO funding}
All the ADA received by the GCSM is managed by a treasury system DAO based on the research made by IOHK for the Zendao \cite{zhangb2}.
 
\section{Creating Job Offers}
An employer signs a job offer posting transaction with his Cardano private key. This transaction will always include an amount of get offered for the task, and a description of said task. The transaction might also include other information about the task, such as a location list, a expected schedule, and other instructions or information about the task.

This is implemented by posting a DataScript transaction to a Smart Contract that we decided to call the "Job Board". This initial transaction may have no ADA associated, and it's intended to broadcast to the community that a new job is available. It has to include enough information for the freelancers to decide if it's interesting to them, and this is implemented by using a DataScript with fields to describe the job being offered, and includes the public key of the employer.

The first iteration of the protocol contains just enough information to prove communication can be achieved, and may be extended later with fields of interest.

\begin{verbatim}
data JobOffer = JobOffer
  { joDescription :: ByteString
  , joPayout      :: Int
  , joOfferer     :: PubKey
  }
  deriving (Show, Eq, Ord, Generic)
PlutusTx.makeLift ''JobOffer
\end{verbatim}


\section{Applying for Job Offers}

In order for a freelancer to find jobs, first he must be checking the place where employers post jobs: the Job Board. Thus, the first step for a freelancer is start listening for transactions in the Job Board address. As employers post new transactions there, the freelancers will be notified by their wallets of these operations. Then, the freelancers must be able to parse back the descriptions. The system uses the Plutus programming language for smart contracts, and this language, when compiled to the Plutus bytecode (known as CEK code), is not readable by human beings. In order for a freelancer to read and understand a job offer, we need to offer him a human-readable version of the posted job. This is done by means of the mechanism described in "A pub-sub mechanism for Cardano and Plutus"\cite{pub-sub-paper}. Once this Plutus bytecode is parsed back to a standard machine representation, it's easy for the system to convert this machine representation into a user interface for the freelancer.

Now that the freelancer can understand what the job demands, he can apply to it. In this context, application means that the freelancer considers himself good enough to deliver the job required, but the employer may disagree. This is why further filtering before the job is done and the payment is delivered is needed. In this case, the freelancer posts his application to a different address, that we call the "Job Application Board". This address is derived automatically from the main Job Board address, hashing into it the specific details of the job.

The freelancer posts to this Job Application Board his public key, and possibly some relevant information. For the first iteration of the protocol, we have decided that the freelancer will only post his public key.
\begin{verbatim}
data JobApplication = JobApplication
  { jaAcceptor    :: PubKey
  }
  deriving (Show, Eq, Generic)
PlutusTx.makeLift ''JobApplication
\end{verbatim}

\section{Accepting Applications}
At this point, both the employer and the freelancer share some common agreement (the job contract), and both parties have copies of the public keys of the other. They can now use standard asymmetric-cipher communication to further discuss the job terms and the ability of the freelancer to deliver the job. This is not covered by this paper, but it's relevant for the mechanism to be complete, and therefore will be addressed in further publications.

After the employer and the freelancer have reached an agreement, it is signed by the employer creating an escrow and locking the funds for payment. At this point, the freelancer can see the employer willingness to pay for the job by observing the escrow with the associated funds on the blockchain.

The underlying datatype in a DataScript that configures an escrow looks like:
\begin{verbatim}
data EscrowSetup = EscrowSetup
  { esJobOffer        :: JobOffer
  , esJobApplication  :: JobApplication
  , esArbiter         :: PubKey
  }
  deriving (Show, Eq, Generic)
PlutusTx.makeLift ''EscrowSetup
\end{verbatim}

At this point, we have introduced another stakeholder without describing his role: the arbiter. The arbiter is a fundamental piece of the dispute resolution process that is described a few sections below.

\section{Escrow Release}
The freelancer now will proceed to deliver the work. When the employer agrees that the work has been delivered, he can release the funds in the escrow to the freelancer by posting a transaction to the escrow smart contract attaching his order to release as a RedeemerScript. This transaction is signed with the employer's private key, and assigns the funds to the freelancer's wallet.

\begin{verbatim}
data EscrowResult
  = EscrowAcceptedByEmployer Signature
  ...
  deriving (Show, Eq, Generic)
PlutusTx.makeLift ''EscrowResult
\end{verbatim}


\section{Dispute Resolution}
Not every time the freelancer and the employer will agree on the outcome of the work delivered. When this happens, the employer may choose to not release the funds, which puts the situation in a stalemate, as the freelancer may not want to work more, and the employer has the funds locked in the smart contract.

To break this stalemate we introduce a third party: an arbiter. The arbiter has been agreed upon before the escrow creation, and his public key is now part of the escrow DataScript. The arbiter has power to release the funds to the freelancer, or back to the employer, but not to himself. It is expected for the arbiter to review any evidence provided by the employer and the employee, and release the escrow in favor of the actor whom he deems is in the right.

The escrow is released by the arbiter by posting a transaction to the escrow address with the result of his judgment (accept escrow to freelancer, or reject escrow back to employer), written as a RedeemerScript, setting the output of the transaction to the wallet of the freelancer or the wallet of the employer, and finally signing the transaction with his private key.

\begin{verbatim}
data EscrowResult
  = EscrowAcceptedByEmployer Signature
  | EscrowAcceptedByArbiter Signature
  | EscrowRejectedByArbiter Signature
  deriving (Show, Eq, Generic)
PlutusTx.makeLift ''EscrowResult
\end{verbatim}

\section{Smart contracts}
Therefore, the system uses two main smart contracts: one for broadcasting and accepting job offers, the other for escrow and dispute resolution.

\subsection{Job Board Smart Contract}
The Job Board Smart Contract is somewhat simple, as it doesn't have to do advanced data processing and validation of transactions. Its main objective is forwarding information from the employer to the freelance, and back. In order to signal that a job is no longer available (for example, because it has been performed and is no longer needed), the employer is offered the option of closing it. This becomes the only validation this smart contract will do: whoever posts to the Job Board is the only one that can take it down.

The system uses the Watched Addresses abstraction provided by Plutus. This abstraction provides a way to specify which addresses (such as the Job Board and the Job Application Board) we want to observe, and the system will tell us non-complete transactions that are currently there. Because we use this system to read back job offers, we can take down a job offer by completing the transaction that posted the job offer, and thus making it disappear from everyone's Watched Addresses.

\begin{verbatim}
jobBoard :: ValidatorScript
jobBoard = ValidatorScript ($$(Ledger.compileScript [||
  \() (JobOffer {joOfferer}) (t :: Validation.PendingTx) ->
    let
        Validation.PendingTx {
          pendingTxInputs=[_],
          pendingTxOutputs=[
            Validation.PendingTxOut {
              pendingTxOutData=Validation.PubKeyTxOut pubkey
            }
          ]
        } = t  -- It's fine if this fails matching,
               -- as it will cause the validator to error out and reject the transaction.

        inSignerIsSameAsOutSigner = $$(Validation.eqPubKey) pubkey joOfferer

    in
    if inSignerIsSameAsOutSigner
    then ()
    else $$(PlutusTx.error) ()
  ||]))
\end{verbatim}

The Job Board Smart Contract demands that whoever posted the job must take it down, and this is the only validation implemented in this contract. This allows the poster to notify the world when the job is available, and when it's no longer available, while preventing malicious third parties from closing the job contract without the employer's approval.

\subsection{Escrow Smart Contract}
The Escrow Smart Contract is significantly more complex than the Job Board Smart Contract for two reasons:

\begin{itemize}
  \item The Escrow has funds that malicious actors may seek to steal.
  \item The Escrow may have to release these funds to different parties.
\end{itemize}

For this reason, the Escrow must have much tighter security and validation.

As usual, every Plutus Smart Contract is configured with a DataScript. In the Escrow DataScript we introduce the full job description (including the public key of the employer), as well as the description of the accepted freelance (including his public key), and the public key of the chosen arbiter.

\begin{verbatim}
jobEscrowContract :: ValidatorScript
jobEscrowContract = ValidatorScript ($$(Ledger.compileScript [||
  \ (result :: EscrowResult)
    (setup :: EscrowSetup)
    (tx :: Validation.PendingTx)
    ->
    let EscrowSetup {
          esJobOffer=JobOffer {
            joOfferer=employerPubKey
          },
          esJobApplication=JobApplication {
            jaAcceptor=employeePubKey
          },
          esArbiter=arbiterPubKey
        } = setup
    in
		...
  ||]))
\end{verbatim}

The Escrow Smart Contract will now validate the actions that try to spend the escrow, and will check that the signer of the action is in position to execute the action, by checking the signatures of these actions.

\begin{verbatim}
jobEscrowContract :: ValidatorScript
jobEscrowContract = ValidatorScript ($$(Ledger.compileScript [||
  \ (result :: EscrowResult)
    (setup :: EscrowSetup)
    (tx :: Validation.PendingTx)
    ->
		...
    let
      eqPubKey = $$(Validation.eqPubKey)
      signedBy' (Signature sig) (PubKey pk) = ...
      (&&) = $$(PlutusTx.and)
    in
    case result of
      EscrowAcceptedByEmployer sig ->
        if (signedBy' sig employerPubKey) && (eqPubKey destPubkey employeePubKey)
        then ()
        else $$(PlutusTx.traceH) "Bad acceptance by employer" ($$(PlutusTx.error) ())
      EscrowAcceptedByArbiter sig ->
        if (signedBy' sig arbiterPubKey) && (eqPubKey destPubkey employeePubKey)
        then ()
        else $$(PlutusTx.traceH) "Bad acceptance by arbiter" ($$(PlutusTx.error) ())
      EscrowRejectedByArbiter sig ->
        if (signedBy' sig arbiterPubKey) && (eqPubKey destPubkey employerPubKey)
        then ()
        else $$(PlutusTx.traceH) "Bad reject by arbiter" ($$(PlutusTx.error) ())
  ||]))
\end{verbatim}


Geolocation

DAO funding


Creating Job Offers



Escrow Creation

Booking inquiries
Booking a Freelancer

Making a transaction
Management Tools
Automatic Timesheets
Communication Between Parties
Job Completion


\begin{thebibliography}{99}

\bibitem{zhangb2}
\href{https://www.lancaster.ac.uk/staff/zhangb2/treasury.pdf}{A Treasury System for Cryptocurrencies:Enabling Better Collaborative Intelligence}
Bingsheng Zhang1, Roman Oliynykov2, and Hamed Balogun3

\bibitem{pub-sub-paper} A pub-sub mechanism for Cardano and Plutus, \url{https://github.com/javcasas/plutus-pubsub-paper/blob/master/paper.pdf}, Javier Casas, March 2019.

\end{thebibliography}

\end{document}
